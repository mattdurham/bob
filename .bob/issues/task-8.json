{
  "id": "task-8",
  "title": "Async PR monitoring with automated agent kickback on events",
  "description": "## Problem\nCurrently agents must actively poll PR status during MONITOR phase, which is:\n- Inefficient (agent sits idle checking status repeatedly)\n- Expensive (consumes agent time/tokens)\n- Slow to respond (only checks every few minutes)\n- Blocks agent from other work\n\n## Goals\nCreate async PR monitoring system where:\n1. Bob monitors PR in background thread/process\n2. Agent receives periodic heartbeat (\"monitoring, nothing new\")\n3. Bob detects events (CI failures, new comments, reviews)\n4. Bob immediately kicks back to agent with event details\n5. Agent wakes up and takes action\n\n## Implementation Architecture\n\n### 1. Background Monitor Process\nCreate async monitor that:\n- Runs in separate goroutine/process\n- Polls GitHub API every 1-5 seconds\n- Tracks PR state changes\n- Detects events: CI failures, new comments, reviews, approvals\n\n### 2. MCP Workflow Integration\nUse MCP workflow async capabilities:\n- `bob.monitor_pr_async` - Start background monitoring\n- `bob.monitor_status` - Get current status (heartbeat)\n- `bob.monitor_events` - Get pending events\n- `bob.monitor_stop` - Stop monitoring\n\n### 3. Event Detection\nMonitor for these events:\n- **CI Check Failures** - Any check transitions to FAILURE\n- **New Comments** - New PR comments or review comments\n- **Review Submitted** - New reviews (approval, changes requested)\n- **Conversation Threads** - New unresolved threads\n- **PR State Changes** - Merged, closed, reopened\n- **Mentions** - Agent/user mentioned in comments\n\n### 4. Agent Notification\nWhen event detected:\n- Store event in workflow state\n- Mark workflow for agent attention\n- Include event details: type, description, URL, action needed\n- Agent retrieves events via `workflow_get_guidance` or special tool\n\n### 5. Heartbeat System\nEvery 1 second, Bob updates status:\n- \"Monitoring PR #8: No events (checked 45 times)\"\n- Agent can poll this status without blocking\n- Shows Bob is alive and working\n\n## Files to Create\n- `cmd/bob/pr_monitor.go` - Background PR monitoring logic\n- `cmd/bob/mcp_monitor.go` - MCP tools for async monitoring\n- `cmd/bob/github_events.go` - GitHub event detection\n\n## Files to Modify\n- `cmd/bob/state_manager.go` - Store monitoring state\n- `cmd/bob/prompts/*/09-monitor.md` - Update to use async monitoring\n- `cmd/bob/mcp_server.go` - Register new MCP tools\n\n## Example Usage Flow\n\n```\nAgent: Start monitoring\n→ bob.monitor_pr_async(prNumber: 8)\n← Monitoring started, check bob.monitor_status for updates\n\n[Agent does other work]\n\nAgent: Check status\n→ bob.monitor_status()\n← Monitoring PR #8: No events (checked 127 times, 2m 15s)\n\n[Bob detects CI failure]\n\nAgent: Check status\n→ bob.monitor_status()\n← EVENT DETECTED: CI check failed - \"golangci-lint\" returned error\n    Action needed: Review failures and fix issues\n    Details: https://github.com/mattdurham/bob/pull/8/checks\n\nAgent: Get events\n→ bob.monitor_events()\n← [{\n    type: \"ci_failure\",\n    check: \"golangci-lint\",\n    status: \"FAILURE\",\n    url: \"...\",\n    logs: \"3 issues found...\"\n  }]\n\nAgent: Takes action (loops back to REVIEW)\n```\n\n## MCP Tools to Add\n\n### bob.monitor_pr_async\nStart async monitoring of a PR\n- **Input**: prNumber, repoOwner, repoName\n- **Output**: monitorId, status\n\n### bob.monitor_status\nGet current monitoring status\n- **Input**: monitorId\n- **Output**: status, eventsCount, lastChecked, uptime\n\n### bob.monitor_events\nGet pending events\n- **Input**: monitorId\n- **Output**: events[] (type, description, url, details)\n\n### bob.monitor_stop\nStop monitoring\n- **Input**: monitorId\n- **Output**: success, finalStatus\n\n## Technical Implementation\n\n### Option 1: Goroutine with Channel\n```go\ntype PRMonitor struct {\n    prNumber   int\n    events     chan PREvent\n    stopChan   chan bool\n    status     string\n    checkCount int\n}\n\nfunc (m *PRMonitor) Start() {\n    go func() {\n        ticker := time.NewTicker(5 * time.Second)\n        for {\n            select {\n            case \u003c-ticker.C:\n                events := m.checkPR()\n                for _, event := range events {\n                    m.events \u003c- event\n                }\n                m.checkCount++\n            case \u003c-m.stopChan:\n                return\n            }\n        }\n    }()\n}\n```\n\n### Option 2: State File Polling\n- Background process writes to `~/.bob/state/monitor-pr-8.json`\n- Agent polls this file\n- Simpler, no channels needed\n\n## Success Criteria\n- Agent can start PR monitoring and continue other work\n- Bob detects CI failures within 5 seconds\n- Bob detects new comments within 5 seconds\n- Agent receives clear event notifications\n- Heartbeat shows Bob is actively monitoring\n- Agent can stop monitoring when done\n- No polling overhead on agent side\n\n## Edge Cases\n- Bob process crashes while monitoring (restart monitoring)\n- Multiple PRs monitored simultaneously\n- GitHub API rate limits (backoff strategy)\n- Network failures (retry with exponential backoff)\n- Monitor running after PR merged (auto-stop)\n- Agent disconnects (monitoring continues, events queued)\n\n## Performance Considerations\n- GitHub API: 5000 requests/hour = 83/minute = 1.4/second\n- Use conditional requests (If-None-Match) to save rate limit\n- Cache PR state, only fetch on changes\n- Batch multiple checks (status + comments + reviews)\n\n## Related\n- Addresses inefficiency in current MONITOR phase\n- Enables true async workflow execution\n- Frees agent to work on other tasks\n- Better user experience (faster response to events)",
  "type": "feature",
  "priority": "high",
  "state": "pending",
  "tags": [
    "enhancement",
    "async",
    "monitoring",
    "github",
    "mcp"
  ],
  "createdAt": "2026-02-09T17:11:23.968811173-05:00",
  "updatedAt": "2026-02-09T17:11:23.968811219-05:00"
}